[
  "#define pi 3.14159\n\nfloat CircleMask(vec2 uvP, float p, float color) {\n    if(uvP.x < p){ \n        return 1.0 - (p - uvP.x) * 50.;\n    } else{ \n        return color; \n    };\n}\n\nfloat glow(float x, float str, float dist){\n    return dist / pow(x, str);\n}\n\nfloat circularSinSDF(vec2 st,  float amplitude, float offset, float freq, float phi, float radius){\n    return abs(st.x - (radius + amplitude * (sin(st.y* freq + phi))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 color = vec3(1.000,0.965,0.741);\n   \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float radius = .2;\n    float glowStrength = .6;\n    float glowDistance = .03;\n    float speed = .25;\n    \n    float numWaves = 6.0;\n    \n    float col = 0.0;\n   \n    vec2 uvP = vec2(sqrt(uv.x * uv.x + uv.y * uv.y), atan(uv.y/uv.x));\n    \n    col += glow(abs(uvP.x-radius), glowStrength, glowDistance);\n    \n    for(float i = 0.0; i< numWaves ; i++){\n        col += glow(circularSinSDF(uvP, .03 + .04 * sin(iTime * speed * i) + cos(uvP.y), 0.0, 2.0, iTime * speed * (i + 1.0) / 2.0, radius), glowStrength, glowDistance);\n    }\n    \n    col = CircleMask(uvP, radius, col);\n\n    \n    // Evil mode\n    //col = 1.0-col;\n    \n    // Output to screen\n    fragColor = vec4(vec3(col) * color,1.0);\n}",
  "float sdBox( vec2 p, vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec3 circle, vec2 pos )\n{\n    float d = length(pos-circle.xy)-circle.z;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    // Circle: vec3(centerX, centerY, radius)\n    vec3 circle = vec3(0., 0., 0.3);\n    vec2 box = vec2(0.2, 0.3);\n    \n    float d = sdBox(uv, box);\n    float c = sin(d*5. + iTime);\n    float sm_c = smoothstep(0., 0.01, c);\n   \n    vec3 col = vec3(0.5, fract(c-0.5)+sm_c/2., 0.3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
  "#define pi 3.14159\n\nfloat sdBox( vec2 p, vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec3 circle, vec2 pos )\n{\n    float d = length(pos-circle.xy)-circle.z;\n    return d;\n}\n\nfloat glow(float x, float str, float dist)\n{\n    return dist / pow(x, str);\n}\n\nfloat circularSinSDF(vec2 st, float amplitude, float offset, float freq, float phi, float radius)\n{\n    return abs(st.x - (radius + amplitude * (sin(st.y* freq + phi))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / iResolution.y;\n    \n    // Circle: vec3(centerX, centerY, radius)\n    vec3 circle = vec3(0.0, 0.0, 0.3);\n    vec2 box = vec2(0.2, 0.3);\n    \n    float d = sdBox(uv, box);\n    \n    // blend box structure from Shader A with circular glow effect from Shader B\n    float radius = 0.2;\n    float glowStrength = 0.6;\n    float glowDistance = 0.03;\n    float speed = 0.25;\n    float numWaves = 6.0;\n    \n    float col = 0.0;\n\n    vec2 uvP = vec2(length(uv), atan(uv.y, uv.x));\n    col += glow(abs(uvP.x - radius), glowStrength, glowDistance);\n    \n    for(float i = 0.0; i < numWaves; i++)\n    {\n        col += glow(circularSinSDF(uvP, 0.03 + 0.04 * sin(iTime * speed * i) + cos(uvP.y), 0.0, 2.0, iTime * speed * (i + 1.0) / 2.0, radius), glowStrength, glowDistance);\n    }\n    \n    // blend both shaders' outputs\n    float combinedEffect = sin(d * 5.0 + iTime) + col;\n    float sm_combinedEffect = smoothstep(0.0, 0.01, combinedEffect);\n  \n    vec3 finalColor = vec3(0.5, fract(combinedEffect - 0.5) + sm_combinedEffect / 2.0, 0.3);\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}\n",
  "#define pi 3.14159\n\nfloat sdBox( vec2 p, vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec3 circle, vec2 pos )\n{\n    float d = length(pos-circle.xy)-circle.z;\n    return d;\n}\n\nfloat glow(float x, float str, float dist)\n{\n    return dist / pow(x, str);\n}\n\nfloat circularSinSDF(vec2 st, float amplitude, float offset, float freq, float phi, float radius)\n{\n    return abs(st.x - (radius + amplitude * (sin(st.y* freq + phi))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / iResolution.y;\n    \n    // Introduce space folding by distorting UV coordinates\n    uv *= 1.0 + 0.2 * sin(uv.y * 10.0 + iTime * 2.0);\n\n    // Circle: vec3(centerX, centerY, radius)\n    vec3 circle = vec3(0.0, 0.0, 0.3);\n    vec2 box = vec2(0.2, 0.3);\n    \n    float d = sdBox(uv, box);\n    \n    // Add a demonic, pulsating glow effect to the box\n    float glowStrength = 0.6;\n    float glowDistance = 0.03;\n    float speed = 0.25;\n    float numWaves = 6.0;\n    \n    float col = 0.0;\n\n    vec2 uvP = vec2(length(uv), atan(uv.y, uv.x));\n    col += glow(abs(uvP.x - 0.3), glowStrength, glowDistance);\n    \n    for(float i = 0.0; i < numWaves; i++)\n    {\n        col += glow(circularSinSDF(uvP, 0.03 + 0.04 * sin(iTime * speed * i) + cos(uvP.y), 0.0, 2.0, iTime * speed * (i + 1.0) / 2.0, 0.3), glowStrength, glowDistance);\n    }\n    \n    // Combine folding space with pulsating glow effect\n    float combinedEffect = 0.8 * sin(d * 5.0 + iTime + uv.x * 3.0) + col;\n    float sm_combinedEffect = smoothstep(0.0, 0.01, combinedEffect);\n  \n    vec3 finalColor = vec3(0.2, 0.2 * fract(combinedEffect + 0.5) + sm_combinedEffect * 0.3, 0.1 + sm_combinedEffect * 0.7);\n\n    // Apply a dark and ominous filter\n    finalColor = mix(finalColor, vec3(0.05, 0.02, 0.01), 0.5);\n\n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}\n",
  "#define pi 3.14159\n\n// Distance function for a box shape\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Glow effect function\nfloat glow(float x, float str, float dist) {\n    return dist / pow(x, str);\n}\n\n// Circular waveform distance function\nfloat circularSinSDF(vec2 st, float amplitude, float offset, float freq, float phi, float radius) {\n    return abs(st.x - (radius + amplitude * (sin(st.y * freq + phi))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Distorting UV coordinates to create space folding effect\n    uv *= 1.0 + 0.2 * sin(uv.y * 10.0 + iTime * 2.0);\n\n    // Shape definitions\n    vec2 box = vec2(0.2, 0.3);\n\n    // Distance field for a box\n    float d = sdBox(uv, box);\n    \n    // Circle effect parameters\n    float radius = 0.2;\n    float glowStrength = 0.6;\n    float glowDistance = 0.03;\n    float speed = 0.25;\n    float numWaves = 6.0;\n    \n    float col = 0.0;\n\n    // Polar coordinates for complex shapes\n    vec2 uvP = vec2(length(uv), atan(uv.y, uv.x));\n    \n    // Circular glow overlay\n    col += glow(abs(uvP.x - radius), glowStrength, glowDistance);\n    \n    // Additional pulsating waveform glows\n    for (float i = 0.0; i < numWaves; i++) {\n        col += glow(circularSinSDF(uvP, 0.03 + 0.04 * sin(iTime * speed * i) + cos(uvP.y), 0.0, 2.0, iTime * speed * (i + 1.0) / 2.0, radius), glowStrength, glowDistance);\n    }\n    \n    // Combining the box distance field with pulsating glow effects\n    float combinedEffect = 0.8 * sin(d * 5.0 + iTime + uv.x * 3.0) + col;\n    float sm_combinedEffect = smoothstep(0.0, 0.01, combinedEffect);\n  \n    vec3 finalColor = vec3(0.4, fract(combinedEffect + 0.5) + sm_combinedEffect * 0.3, 0.2 + sm_combinedEffect * 0.5);\n\n    // Apply an ominous color filter\n    finalColor = mix(finalColor, vec3(0.05, 0.02, 0.01), 0.6);\n\n    // Output final color to screen\n    fragColor = vec4(finalColor, 1.0);\n}\n",
  "#define pi 3.14159\n\n// Compute distance to a circular shape with pulsating effect\nfloat circularPulseSDF(vec2 st, float amplitude, float freq, float phi, float radius) {\n    return abs(st.x - (radius + amplitude * sin(st.y * freq + phi)));\n}\n\n// Distance function for a box shape\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// Glow effect function\nfloat glow(float x, float str, float dist) {\n    return dist / pow(x, str);\n}\n\n// Circular waveform distance function\nfloat circularSinSDF(vec2 st, float amplitude, float offset, float freq, float phi, float radius) {\n    return abs(st.x - (radius + amplitude * (sin(st.y * freq + phi) + cos(st.x * freq + phi))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n    // Distort UV coordinates with combined space folding effects from both shaders\n    uv *= 1.0 + 0.2 * sin(uv.y * 10.0 + iTime * 2.0) + 0.1 * cos(uv.x * 8.0 + iTime * 2.0);\n\n    // Shape Definitions\n    vec2 box = vec2(0.2, 0.3);\n    float radius = 0.2;\n\n    // Distance field for a box\n    float d = sdBox(uv, box);\n\n    // Glow and pulse parameters\n    float glowStrength = 0.6;\n    float glowDistance = 0.03 + 0.01 * sin(iTime * 0.5);\n    float speed = 0.3;\n    float numElements = 10.0;\n    \n    // Polar coordinates for complex shapes\n    vec2 uvP = vec2(length(uv), atan(uv.y, uv.x));\n    \n    // Initialize color effect accumulator\n    float col = 0.0;\n\n    // Combining pulsating and sine waveforms with glow effects\n    for (float i = 0.0; i < numElements; i++) {\n        float pulse1 = circularPulseSDF(uvP, 0.03 + 0.02 * cos(iTime * speed * i), 5.0, iTime * speed * i, radius);\n        float pulse2 = circularSinSDF(uvP, 0.04 + sin(iTime * speed * i), 0.0, 3.0, iTime * speed * (i + 1.0), radius);\n        float pulse3 = circularSinSDF(uvP, 0.03 + 0.04 * sin(iTime * speed * i) + cos(uvP.y), 0.0, 2.0, iTime * speed * (i + 1.0) / 2.0, radius);\n        col += glow(pulse1, glowStrength, glowDistance) + glow(pulse2, glowStrength, glowDistance) + glow(pulse3, glowStrength, glowDistance);\n    }\n\n    // Adding a circular glow effect overlay\n    col += glow(abs(uvP.x - radius), glowStrength, glowDistance);\n\n    // Combining the box distance field with pulsating glow effects\n    float combinedEffect = 0.8 * sin(d * 5.0 + iTime + uv.x * 3.0) + col;\n    float sm_combinedEffect = smoothstep(0.1, 0.2, combinedEffect);\n\n    // Create a combined color palette with shifting tones\n    vec3 finalColor = vec3(0.4, fract(combinedEffect + 0.5) + sm_combinedEffect * 0.3, 0.2 + sm_combinedEffect * 0.5);\n\n    // Apply an ominous color filter\n    finalColor = mix(finalColor, vec3(0.05, 0.02, 0.01), 0.7);\n\n    // Output final color to screen\n    fragColor = vec4(finalColor, 1.0);\n}\n"
]