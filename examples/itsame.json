[
  "// Voxel Raymarching Shader with Complex Geometry and Moving Camera\n// Colors and voxel structure influenced by iChannel0 (webcam input)\n\n// Warp function to create non-Euclidean effect\nvec3 warpSpace(vec3 p) {\n    p.xy += 0.2 * sin(p.z * 3.0 + iTime);\n    p.xz += 0.2 * cos(p.y * 3.0 + iTime);\n    return p;\n}\n\n// Function to create a sphere shape\nfloat sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\n// Function to create a cube shape\nfloat cube(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Function to create a torus shape\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// Function to create a Mandelbulb fractal shape\nfloat mandelbulb(vec3 p) {\n    vec3 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < 8; i++) {\n        r = length(z);\n        if (r > 2.0) break;\n\n        // Convert to polar coordinates\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        dr =  pow(r, 7.0 - 1.0) * 7.0 * dr + 1.0;\n\n        // Scale and rotate the point\n        float zr = pow(r, 7.0);\n        theta = theta * 7.0;\n        phi = phi * 7.0;\n\n        // Convert back to Cartesian coordinates\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n// Function to create a Menger Sponge fractal shape\nfloat mengerSponge(vec3 p) {\n    for (int i = 0; i < 4; i++) {\n        p = abs(p);\n        if (p.x < p.y) p.xy = p.yx;\n        if (p.x < p.z) p.xz = p.zx;\n        if (p.y < p.z) p.yz = p.zy;\n        p = p * 3.0 - 2.0;\n    }\n    return length(p) / pow(3.0, 4.0);\n}\n\n// Adjusted map function to create a more interesting voxel structure\nfloat map(vec3 p) {\n    p = warpSpace(p); // Apply non-Euclidean warp\n    vec3 q = mod(p, 2.0) - 1.0; // Create repeating voxel pattern\n\n    // Combine different shapes to create complex geometry\n    float d = sphere(q, 0.3);\n    d = min(d, cube(q, vec3(0.3)));\n    d = min(d, torus(q, vec2(0.5, 0.1)));\n    d = min(d, mandelbulb(p));\n    d = min(d, mengerSponge(p));\n\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    float brightness = texture(iChannel0, uv).r; // Sample brightness from webcam data\n\n    return d + 0.1 * brightness * sin(p.x * 3.0) * cos(p.y * 3.0); // Modulate shape size with brightness\n}\n\n// Modified getColor function to use webcam input for coloring\nvec3 getColor(vec3 p) {\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    vec3 webcamColor = texture(iChannel0, uv).rgb; // Sample webcam data\n    return webcamColor; // Return the sampled color\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 100; i++) { // Iterate for raymarching\n        vec3 p = ro + t * rd; // Calculate point along ray\n        float d = map(p); // Get distance to nearest voxel\n        if (d < 0.01) { // If close enough to a voxel\n            col = getColor(p); // Determine color based on webcam data\n            break; // Exit loop\n        }\n        t += d; // Increment distance\n    }\n    return col; // Return the final color\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Create pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Define dynamic camera position\n    float time = iTime * 0.5;\n    vec3 ro = vec3(2.0 * cos(time), 0.5 * sin(time * 0.5), 2.0 * sin(time)); // Camera position moving in a circle with vertical motion\n    vec3 lookAt = vec3(0.0, 0.0, 0.0); // Look at the center of the scene\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward); // Ray direction\n\n    // Raymarching\n    vec3 col = raymarch(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0); // Set fragment color\n}\n",
  "// Voxel Raymarching Shader with Spikier Geometry and Moving Camera\n// Colors and voxel structure influenced by iChannel0 (webcam input)\n\n// Warp function to create non-Euclidean effect\nvec3 warpSpace(vec3 p) {\n    p.xy += 0.2 * sin(p.z * 3.0 + iTime);\n    p.xz += 0.2 * cos(p.y * 3.0 + iTime);\n    return p;\n}\n\n// Function to create a spiky cube shape\nfloat spikyCube(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) * 0.5;\n}\n\n// Function to create a spiky torus shape\nfloat spikyTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y * 0.5;\n}\n\n// Function to create a spiky shape\nfloat spikyShape(vec3 p) {\n    return length(p) - 0.3 + 0.2 * sin(10.0 * p.x) * cos(10.0 * p.y);\n}\n\n// Function to create a Mandelbulb fractal shape\nfloat mandelbulb(vec3 p) {\n    vec3 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int i = 0; i < 8; i++) {\n        r = length(z);\n        if (r > 2.0) break;\n\n        // Convert to polar coordinates\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        dr =  pow(r, 7.0 - 1.0) * 7.0 * dr + 1.0;\n\n        // Scale and rotate the point\n        float zr = pow(r, 7.0);\n        theta = theta * 7.0;\n        phi = phi * 7.0;\n\n        // Convert back to Cartesian coordinates\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n// Function to create a Menger Sponge fractal shape\nfloat mengerSponge(vec3 p) {\n    for (int i = 0; i < 4; i++) {\n        p = abs(p);\n        if (p.x < p.y) p.xy = p.yx;\n        if (p.x < p.z) p.xz = p.zx;\n        if (p.y < p.z) p.yz = p.zy;\n        p = p * 3.0 - 2.0;\n    }\n    return length(p) / pow(3.0, 4.0);\n}\n\n// Adjusted map function to create a more interesting voxel structure\nfloat map(vec3 p) {\n    p = warpSpace(p); // Apply non-Euclidean warp\n    vec3 q = mod(p, 2.0) - 1.0; // Create repeating voxel pattern\n\n    // Combine different shapes to create complex geometry\n    float d = spikyShape(q);\n    d = min(d, spikyCube(q, vec3(0.3)));\n    d = min(d, spikyTorus(q, vec2(0.5, 0.1)));\n    d = min(d, mandelbulb(p));\n    d = min(d, mengerSponge(p));\n\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    float brightness = texture(iChannel0, uv).r; // Sample brightness from webcam data\n\n    return d + 0.1 * brightness * sin(p.x * 3.0) * cos(p.y * 3.0); // Modulate shape size with brightness\n}\n\n// Modified getColor function to use webcam input for coloring\nvec3 getColor(vec3 p) {\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    vec3 webcamColor = texture(iChannel0, uv).rgb; // Sample webcam data\n    return webcamColor; // Return the sampled color\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 100; i++) { // Iterate for raymarching\n        vec3 p = ro + t * rd; // Calculate point along ray\n        float d = map(p); // Get distance to nearest voxel\n        if (d < 0.01) { // If close enough to a voxel\n            col = getColor(p); // Determine color based on webcam data\n            break; // Exit loop\n        }\n        t += d; // Increment distance\n    }\n    return col; // Return the final color\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Create pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Define dynamic camera position\n    float time = iTime * 0.5;\n    vec3 ro = vec3(2.0 * cos(time), 0.5 * sin(time * 0.5), 2.0 * sin(time)); // Camera position moving in a circle with vertical motion\n    vec3 lookAt = vec3(0.0, 0.0, 0.0); // Look at the center of the scene\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward); // Ray direction\n\n    // Raymarching\n    vec3 col = raymarch(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0); // Set fragment color\n}\n",
  "// Voxel Raymarching Shader with Spikier Geometry and Moving Camera\n// Colors and voxel structure influenced by iChannel0 (webcam input)\n\n// Warp function to create non-Euclidean effect\nvec3 warpSpace(vec3 p) {\n    p.xy += 0.4 * sin(p.z * 6.0 + iTime);\n    p.xz += 0.4 * cos(p.y * 6.0 + iTime);\n    return p;\n}\n\n// Function to create a spiky cube shape\nfloat spikyCube(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) * 0.3;\n}\n\n// Function to create a spiky torus shape\nfloat spikyTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y * 0.3;\n}\n\n// Function to create a spiky shape\nfloat spikyShape(vec3 p) {\n    return length(p) - 0.3 + 0.4 * sin(20.0 * p.x) * cos(20.0 * p.y);\n}\n\n// Adjusted map function to create a more interesting voxel structure\nfloat map(vec3 p) {\n    p = warpSpace(p); // Apply non-Euclidean warp\n    vec3 q = mod(p, 2.0) - 1.0; // Create repeating voxel pattern\n\n    // Combine different shapes to create complex geometry\n    float d = spikyShape(q);\n    d = min(d, spikyCube(q, vec3(0.3)));\n    d = min(d, spikyTorus(q, vec2(0.5, 0.1)));\n\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    float brightness = texture(iChannel0, uv).r; // Sample brightness from webcam data\n\n    return d + 0.1 * brightness * sin(p.x * 3.0) * cos(p.y * 3.0); // Modulate shape size with brightness\n}\n\n// Modified getColor function to use webcam input for coloring\nvec3 getColor(vec3 p) {\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    vec3 webcamColor = texture(iChannel0, uv).rgb; // Sample webcam data\n    return webcamColor; // Return the sampled color\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 100; i++) { // Iterate for raymarching\n        vec3 p = ro + t * rd; // Calculate point along ray\n        float d = map(p); // Get distance to nearest voxel\n        if (d < 0.01) { // If close enough to a voxel\n            col = getColor(p); // Determine color based on webcam data\n            break; // Exit loop\n        }\n        t += d; // Increment distance\n    }\n    return col; // Return the final color\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Create pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Define dynamic camera position\n    float time = iTime * 0.5;\n    vec3 ro = vec3(2.0 * cos(time), 0.5 * sin(time * 0.5), 2.0 * sin(time)); // Camera position moving in a circle with vertical motion\n    vec3 lookAt = vec3(0.0, 0.0, 0.0); // Look at the center of the scene\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward); // Ray direction\n\n    // Raymarching\n    vec3 col = raymarch(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0); // Set fragment color\n}\n",
  "// Voxel Raymarching Shader with Spikier Geometry and Moving Camera\n// Colors and voxel structure influenced by iChannel0 (webcam input)\n\n// Warp function to create non-Euclidean effect\nvec3 warpSpace(vec3 p) {\n    p.xy += 0.4 * sin(p.z * 6.0 + iTime);\n    p.xz += 0.4 * cos(p.y * 6.0 + iTime);\n    return p;\n}\n\n// Function to create a spiky cube shape\nfloat spikyCube(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) * 0.3;\n}\n\n// Function to create a spiky torus shape\nfloat spikyTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y * 0.3;\n}\n\n// Function to create a spiky shape\nfloat spikyShape(vec3 p) {\n    return length(p) - 0.3 + 0.4 * sin(20.0 * p.x) * cos(20.0 * p.y);\n}\n\n// Adjusted map function to create a more interesting voxel structure\nfloat map(vec3 p) {\n    p = warpSpace(p); // Apply non-Euclidean warp\n    vec3 q = mod(p, 2.0) - 1.0; // Create repeating voxel pattern\n\n    // Combine different shapes to create complex geometry\n    float d = spikyShape(q);\n    d = min(d, spikyCube(q, vec3(0.3)));\n    d = min(d, spikyTorus(q, vec2(0.5, 0.1)));\n\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    float brightness = texture(iChannel0, uv).r; // Sample brightness from webcam data\n\n    return d + 0.1 * brightness * sin(p.x * 3.0) * cos(p.y * 3.0); // Modulate shape size with brightness\n}\n\n// Function to convert RGB to HSV\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Modified getColor function to use webcam input for coloring and remap colors\nvec3 getColor(vec3 p) {\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    vec3 webcamColor = texture(iChannel0, uv).rgb; // Sample webcam data\n    \n    // Convert RGB to HSV\n    vec3 hsvColor = rgb2hsv(webcamColor);\n    \n    // Rotate the hue\n    hsvColor.x += 0.5; // Rotate hue by 180 degrees\n    if (hsvColor.x > 1.0) hsvColor.x -= 1.0;\n    \n    // Convert back to RGB\n    vec3 remappedColor = hsv2rgb(hsvColor);\n    \n    return remappedColor; // Return the remapped color\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 100; i++) { // Iterate for raymarching\n        vec3 p = ro + t * rd; // Calculate point along ray\n        float d = map(p); // Get distance to nearest voxel\n        if (d < 0.01) { // If close enough to a voxel\n            col = getColor(p); // Determine color based on webcam data\n            break; // Exit loop\n        }\n        t += d; // Increment distance\n    }\n    return col; // Return the final color\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Create pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Define dynamic camera position\n    float time = iTime * 0.5;\n    vec3 ro = vec3(2.0 * cos(time), 0.5 * sin(time * 0.5), 2.0 * sin(time)); // Camera position moving in a circle with vertical motion\n    vec3 lookAt = vec3(0.0, 0.0, 0.0); // Look at the center of the scene\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward); // Ray direction\n\n    // Raymarching\n    vec3 col = raymarch(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0); // Set fragment color\n}\n",
  "// Voxel Raymarching Shader with Spikier Geometry and Moving Camera\n// Colors and voxel structure influenced by iChannel0 (webcam input)\n\n// Warp function to create non-Euclidean effect\nvec3 warpSpace(vec3 p) {\n    p.xy += 0.4 * sin(p.z * 6.0 + iTime);\n    p.xz += 0.4 * cos(p.y * 6.0 + iTime);\n    return p;\n}\n\n// Function to create a spiky cube shape\nfloat spikyCube(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) * 0.3;\n}\n\n// Function to create a spiky torus shape\nfloat spikyTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y * 0.3;\n}\n\n// Function to create a spiky shape\nfloat spikyShape(vec3 p) {\n    return length(p) - 0.3 + 0.4 * sin(20.0 * p.x) * cos(20.0 * p.y);\n}\n\n// Adjusted map function to create a more interesting voxel structure\nfloat map(vec3 p) {\n    p = warpSpace(p); // Apply non-Euclidean warp\n    vec3 q = mod(p, 2.0) - 1.0; // Create repeating voxel pattern\n\n    // Combine different shapes to create complex geometry\n    float d = spikyShape(q);\n    d = min(d, spikyCube(q, vec3(0.3)));\n    d = min(d, spikyTorus(q, vec2(0.5, 0.1)));\n\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    float brightness = texture(iChannel0, uv).r; // Sample brightness from webcam data\n\n    return d + 0.1 * brightness * sin(p.x * 3.0) * cos(p.y * 3.0); // Modulate shape size with brightness\n}\n\n// Function to convert RGB to HSV\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Modified getColor function to use webcam input for coloring and remap colors\nvec3 getColor(vec3 p) {\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    vec3 webcamColor = texture(iChannel0, uv).rgb; // Sample webcam data\n    \n    // Convert RGB to HSV\n    vec3 hsvColor = rgb2hsv(webcamColor);\n    \n    // Rotate the hue and adjust saturation and brightness\n    hsvColor.x += 0.5; // Rotate hue by 180 degrees\n    if (hsvColor.x > 1.0) hsvColor.x -= 1.0;\n    hsvColor.y = clamp(hsvColor.y * 1.5, 0.0, 1.0); // Increase saturation\n    hsvColor.z = clamp(hsvColor.z * 1.2, 0.0, 1.0); // Increase brightness\n    \n    // Convert back to RGB\n    vec3 remappedColor = hsv2rgb(hsvColor);\n    \n    return remappedColor; // Return the remapped color\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 100; i++) { // Iterate for raymarching\n        vec3 p = ro + t * rd; // Calculate point along ray\n        float d = map(p); // Get distance to nearest voxel\n        if (d < 0.01) { // If close enough to a voxel\n            col = getColor(p); // Determine color based on webcam data\n            break; // Exit loop\n        }\n        t += d; // Increment distance\n    }\n    return col; // Return the final color\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Create pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Define dynamic camera position\n    float time = iTime * 0.5;\n    vec3 ro = vec3(2.0 * cos(time), 0.5 * sin(time * 0.5), 2.0 * sin(time)); // Camera position moving in a circle with vertical motion\n    vec3 lookAt = vec3(0.0, 0.0, 0.0); // Look at the center of the scene\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward); // Ray direction\n\n    // Raymarching\n    vec3 col = raymarch(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0); // Set fragment color\n}\n",
  "// Voxel Raymarching Shader with Spikier Geometry and Moving Camera\n// Colors and voxel structure influenced by iChannel0 (webcam input)\n\n// Warp function to create non-Euclidean effect\nvec3 warpSpace(vec3 p) {\n    p.xy += 0.4 * sin(p.z * 6.0 + iTime);\n    p.xz += 0.4 * cos(p.y * 6.0 + iTime);\n    return p;\n}\n\n// Function to create a spiky cube shape\nfloat spikyCube(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) * 0.3;\n}\n\n// Function to create a spiky torus shape\nfloat spikyTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y * 0.3;\n}\n\n// Function to create a spiky shape\nfloat spikyShape(vec3 p) {\n    return length(p) - 0.3 + 0.4 * sin(20.0 * p.x) * cos(20.0 * p.y);\n}\n\n// Adjusted map function to create a more interesting voxel structure\nfloat map(vec3 p) {\n    p = warpSpace(p); // Apply non-Euclidean warp\n    vec3 q = mod(p, 2.0) - 1.0; // Create repeating voxel pattern\n\n    // Combine different shapes to create complex geometry\n    float d = spikyShape(q);\n    d = min(d, spikyCube(q, vec3(0.3)));\n    d = min(d, spikyTorus(q, vec2(0.5, 0.1)));\n\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    float brightness = texture(iChannel0, uv).r; // Sample brightness from webcam data\n\n    return d + 0.1 * brightness * sin(p.x * 3.0) * cos(p.y * 3.0); // Modulate shape size with brightness\n}\n\n// Function to convert RGB to HSV\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Function to convert HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Modified getColor function to use webcam input for coloring and remap colors\nvec3 getColor(vec3 p) {\n    vec2 uv = vec2(mod(p.x, 1.0), mod(p.y, 1.0)); // Use x and y coordinates for sampling\n    vec3 webcamColor = texture(iChannel0, uv).rgb; // Sample webcam data\n    \n    // Convert RGB to HSV\n    vec3 hsvColor = rgb2hsv(webcamColor);\n    \n    // Rotate the hue and adjust saturation and brightness\n    hsvColor.x += 0.5; // Rotate hue by 180 degrees\n    if (hsvColor.x > 1.0) hsvColor.x -= 1.0;\n    hsvColor.y = clamp(hsvColor.y * 1.5, 0.0, 1.0); // Increase saturation\n    hsvColor.z = clamp(hsvColor.z * 1.2, 0.0, 1.0); // Increase brightness\n    \n    // Convert back to RGB\n    vec3 remappedColor = hsv2rgb(hsvColor);\n    \n    return remappedColor; // Return the remapped color\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 100; i++) { // Iterate for raymarching\n        vec3 p = ro + t * rd; // Calculate point along ray\n        float d = map(p); // Get distance to nearest voxel\n        if (d < 0.01) { // If close enough to a voxel\n            col = getColor(p); // Determine color based on webcam data\n            break; // Exit loop\n        }\n        t += d; // Increment distance\n    }\n    return col; // Return the final color\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Create pixel coordinates\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Define dynamic camera position\n    float time = iTime * 0.5;\n    vec3 ro = vec3(2.0 * cos(time), 0.5 * sin(time * 0.5), 2.0 * sin(time)); // Camera position moving in a circle with vertical motion\n    vec3 lookAt = vec3(0.0, 0.0, 0.0); // Look at the center of the scene\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward); // Ray direction\n\n    // Raymarching\n    vec3 col = raymarch(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0); // Set fragment color\n}\n"
]