[
  "// Expanded palette and increased visibility of iChannel0 texture\n\n// Define a 4x4 Bayer matrix for dithering\nconst float ditherMatrix[16] = float[16](\n    0.0,  8.0,  2.0, 10.0,\n   12.0,  4.0, 14.0,  6.0,\n    3.0, 11.0,  1.0,  9.0,\n   15.0,  7.0, 13.0,  5.0\n);\n\n// Expanded color palette\nconst vec3 palette[8] = vec3[8](\n    vec3(0.0, 0.0, 0.0), // Black\n    vec3(1.0, 0.0, 0.0), // Red\n    vec3(0.0, 1.0, 0.0), // Green\n    vec3(0.0, 0.0, 1.0), // Blue\n    vec3(1.0, 1.0, 0.0), // Yellow\n    vec3(0.0, 1.0, 1.0), // Cyan\n    vec3(1.0, 0.0, 1.0), // Magenta\n    vec3(1.0, 1.0, 1.0)  // White\n);\n\n// Function to calculate Truchet tile pattern\nfloat truchetPattern(vec2 tilePos, vec2 tileOffset) {\n    vec2 p = tileOffset - 0.5;\n    return step(0.0, sin(tilePos.x + tilePos.y + p.x * p.y * 10.0));\n}\n\n// Function to generate dynamic color based on tile pattern\nvec3 dynamicColor(float pattern, vec3 baseColor) {\n    return mix(baseColor, vec3(1.0, 0.5, 0.2), pattern);\n}\n\n// Function to generate complex, evolving background\nvec3 evolvingBackground(vec2 uv, float time) {\n    vec3 bgColor = 0.1 * vec3(sin(time + uv.x * 3.0), cos(time + uv.y * 3.0), sin(time * 0.5 + uv.x + uv.y));\n    bgColor += 0.1 * vec3(sin(time * 0.3 + uv.y * 2.0), cos(time * 0.2 + uv.x * 2.0), sin(time * 0.4 + uv.x * uv.y));\n    return bgColor;\n}\n\n// Function to apply microphone-based distortion\nvec2 applyMicDistortion(vec2 uv, float time) {\n    // Use frequency data from microphone input\n    float micInputFreq = texture(iChannel1, vec2(uv.y, 0.0)).r;\n    float micInputWave = texture(iChannel1, vec2(uv.y, 1.0)).r;\n    float distortionFreq = sin(micInputFreq * 10.0 + time) * 0.1;\n    float distortionWave = sin(micInputWave * 10.0 + time) * 0.1;\n    return uv + vec2(distortionFreq, distortionWave);\n}\n\n// Function to find the closest color in the palette\nvec3 remapColor(vec3 color) {\n    float minDist = 1e6;\n    vec3 closestColor = palette[0];\n    for (int i = 0; i < 8; i++) {\n        float dist = distance(color, palette[i]);\n        if (dist < minDist) {\n            minDist = dist;\n            closestColor = palette[i];\n        }\n    }\n    return closestColor;\n}\n\n// Function to apply dithering\nvec3 applyDithering(vec3 color, vec2 uv) {\n    int x = int(mod(uv.x * 4.0, 4.0));\n    int y = int(mod(uv.y * 4.0, 4.0));\n    float threshold = ditherMatrix[y * 4 + x] / 16.0;\n    return color + vec3(threshold / 255.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Apply microphone-based distortion\n    uv = applyMicDistortion(uv, iTime);\n\n    // Truchet tiling\n    const float tileSize = 20.0;\n    vec2 tileUV = uv * tileSize;\n\n    // Apply rotation to the tile coordinates\n    float angle = sin(iTime) * 3.14159 / 4.0;\n    mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    tileUV = rotation * tileUV;\n\n    vec2 tilePos = floor(tileUV);\n    vec2 tileOffset = fract(tileUV);\n\n    // Truchet tile pattern\n    float pattern = truchetPattern(tilePos, tileOffset);\n\n    // Sample the webcam texture (iChannel0)\n    vec3 webcamColor = texture(iChannel0, uv).rgb;\n    vec3 tileColor = dynamicColor(pattern, webcamColor);\n\n    // Enhanced evolving background\n    vec3 bgColor = evolvingBackground(uv, iTime);\n\n    // Blend the Truchet tile color with the evolving background using smooth transition\n    vec3 finalColor = mix(bgColor, tileColor, 0.7 + 0.3 * pattern);\n\n    // Remap the color to the palette and apply dithering\n    finalColor = remapColor(finalColor);\n    finalColor = applyDithering(finalColor, uv);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n",
  "// Function to cycle colors over time\nvec3 cycleColor(vec3 color, float time) {\n    float cycleSpeed = 1.0; // Increased speed of color cycling\n    return vec3(\n        sin(color.r + time * cycleSpeed),\n        sin(color.g + time * cycleSpeed + 2.0),\n        sin(color.b + time * cycleSpeed + 4.0)\n    ) * 0.5 + 0.5;\n}\n\n// Function to apply a prominent glitch effect based on time and mouse position\nvec2 applyGlitchEffect(vec2 uv, vec2 mouse, float time) {\n    float glitchStrength = 0.2; // Increased glitch strength\n    uv += sin(uv.y * 10.0 + time * 5.0) * glitchStrength * vec2(mouse.x - 0.5, mouse.y - 0.5);\n    return uv;\n}\n\n// Function to apply microphone-based distortion\nvec2 applyMicDistortion(vec2 uv, float time) {\n    // Use frequency data from microphone input\n    float micInputFreq = texture(iChannel1, vec2(uv.y, 0.0)).r;\n    float micInputWave = texture(iChannel1, vec2(uv.y, 1.0)).r;\n    float distortionFreq = sin(micInputFreq * 10.0 + time) * 0.1;\n    float distortionWave = sin(micInputWave * 10.0 + time) * 0.1;\n    return uv + vec2(distortionFreq, distortionWave);\n}\n\n// Function to generate complex, evolving background\nvec3 evolvingBackground(vec2 uv, float time) {\n    vec3 bgColor = 0.1 * vec3(sin(time + uv.x * 3.0), cos(time + uv.y * 3.0), sin(time * 0.5 + uv.x + uv.y));\n    bgColor += 0.1 * vec3(sin(time * 0.3 + uv.y * 2.0), cos(time * 0.2 + uv.x * 2.0), sin(time * 0.4 + uv.x * uv.y));\n    return bgColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Apply glitch effect\n    uv = applyGlitchEffect(uv, iMouse.xy / iResolution.xy, iTime);\n\n    // Apply microphone-based distortion\n    uv = applyMicDistortion(uv, iTime);\n\n    // Sample the webcam texture (iChannel0)\n    vec3 webcamColor = texture(iChannel0, uv).rgb;\n\n    // Enhanced evolving background\n    vec3 bgColor = evolvingBackground(uv, iTime);\n\n    // Blend the webcam color with the evolving background using smooth transition\n    vec3 finalColor = mix(bgColor, webcamColor, 0.7);\n\n    // Cycle colors over time\n    finalColor = cycleColor(finalColor, iTime);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n",
  "// Define a 4x4 Bayer matrix for dithering\nconst float ditherMatrix[16] = float[16](\n    0.0,  8.0,  2.0, 10.0,\n   12.0,  4.0, 14.0,  6.0,\n    3.0, 11.0,  1.0,  9.0,\n   15.0,  7.0, 13.0,  5.0\n);\n\n// Expanded color palette\nconst vec3 palette[8] = vec3[8](\n    vec3(0.0, 0.0, 0.0), // Black\n    vec3(1.0, 0.0, 0.0), // Red\n    vec3(0.0, 1.0, 0.0), // Green\n    vec3(0.0, 0.0, 1.0), // Blue\n    vec3(1.0, 1.0, 0.0), // Yellow\n    vec3(0.0, 1.0, 1.0), // Cyan\n    vec3(1.0, 0.0, 1.0), // Magenta\n    vec3(1.0, 1.0, 1.0)  // White\n);\n\n// Function to cycle colors over time\nvec3 cycleColor(vec3 color, float time) {\n    float cycleSpeed = 1.0; // Increased speed of color cycling\n    return vec3(\n        sin(color.r + time * cycleSpeed),\n        sin(color.g + time * cycleSpeed + 2.0),\n        sin(color.b + time * cycleSpeed + 4.0)\n    ) * 0.5 + 0.5;\n}\n\n// Function to apply a prominent glitch effect based on time and mouse position\nvec2 applyGlitchEffect(vec2 uv, vec2 mouse, float time) {\n    float glitchStrength = 0.2; // Increased glitch strength\n    uv += sin(uv.y * 10.0 + time * 5.0) * glitchStrength * vec2(mouse.x - 0.5, mouse.y - 0.5);\n    return uv;\n}\n\n// Function to apply microphone-based distortion\nvec2 applyMicDistortion(vec2 uv, float time) {\n    // Use frequency data from microphone input\n    float micInputFreq = texture(iChannel1, vec2(uv.y, 0.0)).r;\n    float micInputWave = texture(iChannel1, vec2(uv.y, 1.0)).r;\n    float distortionFreq = sin(micInputFreq * 10.0 + time) * 0.1;\n    float distortionWave = sin(micInputWave * 10.0 + time) * 0.1;\n    return uv + vec2(distortionFreq, distortionWave);\n}\n\n// Function to calculate Truchet tile pattern\nfloat truchetPattern(vec2 tilePos, vec2 tileOffset) {\n    vec2 p = tileOffset - 0.5;\n    return step(0.0, sin(tilePos.x + tilePos.y + p.x * p.y * 10.0));\n}\n\n// Function to generate dynamic color based on tile pattern\nvec3 dynamicColor(float pattern, vec3 baseColor) {\n    return mix(baseColor, vec3(1.0, 0.5, 0.2), pattern);\n}\n\n// Function to generate complex, evolving background\nvec3 evolvingBackground(vec2 uv, float time) {\n    vec3 bgColor = 0.1 * vec3(sin(time + uv.x * 3.0), cos(time + uv.y * 3.0), sin(time * 0.5 + uv.x + uv.y));\n    bgColor += 0.1 * vec3(sin(time * 0.3 + uv.y * 2.0), cos(time * 0.2 + uv.x * 2.0), sin(time * 0.4 + uv.x * uv.y));\n    return bgColor;\n}\n\n// Function to find the closest color in the palette\nvec3 remapColor(vec3 color) {\n    float minDist = 1e6;\n    vec3 closestColor = palette[0];\n    for (int i = 0; i < 8; i++) {\n        float dist = distance(color, palette[i]);\n        if (dist < minDist) {\n            minDist = dist;\n            closestColor = palette[i];\n        }\n    }\n    return closestColor;\n}\n\n// Function to apply dithering\nvec3 applyDithering(vec3 color, vec2 uv) {\n    int x = int(mod(uv.x * 4.0, 4.0));\n    int y = int(mod(uv.y * 4.0, 4.0));\n    float threshold = ditherMatrix[y * 4 + x] / 16.0;\n    return color + vec3(threshold / 255.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Apply glitch effect\n    uv = applyGlitchEffect(uv, iMouse.xy / iResolution.xy, iTime);\n\n    // Apply microphone-based distortion\n    uv = applyMicDistortion(uv, iTime);\n\n    // Truchet tiling\n    const float tileSize = 20.0;\n    vec2 tileUV = uv * tileSize;\n\n    // Apply rotation to the tile coordinates\n    float angle = sin(iTime) * 3.14159 / 4.0;\n    mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    tileUV = rotation * tileUV;\n\n    vec2 tilePos = floor(tileUV);\n    vec2 tileOffset = fract(tileUV);\n\n    // Truchet tile pattern\n    float pattern = truchetPattern(tilePos, tileOffset);\n\n    // Sample the webcam texture (iChannel0)\n    vec3 webcamColor = texture(iChannel0, uv).rgb;\n    vec3 tileColor = dynamicColor(pattern, webcamColor);\n\n    // Enhanced evolving background\n    vec3 bgColor = evolvingBackground(uv, iTime);\n\n    // Blend the Truchet tile color with the evolving background using smooth transition\n    vec3 finalColor = mix(bgColor, tileColor, 0.7 + 0.3 * pattern);\n\n    // Cycle colors over time\n    finalColor = cycleColor(finalColor, iTime);\n\n    // Remap the color to the palette and apply dithering\n    finalColor = remapColor(finalColor);\n    finalColor = applyDithering(finalColor, uv);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n"
]