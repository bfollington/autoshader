[
  "#define R(a)a=vec2(a.x+a.y,a.x-a.y)*.7\n#define G(a,n)R(a);a=abs(a+0.02)-n;R(a)\n\n// Function to create a star pattern\nfloat happy_star(vec2 uv, float anim) {\n    uv = abs(uv);\n    vec2 pos = min(uv.xy / uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0 + p * (p * p - 1.5)) / (uv.x + uv.y);      \n} \n \n// Function to generate a color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 O, vec2 C) {\n    // Sample the microphone input (FFT)\n    float micInput = texture2D(iChannel1, vec2(0.0, 0.0)).r;\n\n    O = vec4(0);\n    vec2 cPos = -1.0 + 2.0 * C.xy / iResolution.xy;\n   \n    // Distance of current pixel from center\n    float cLength = length(cPos);\n    vec2 uv2 = (C - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = palette(length(uv2) + 0.4 + iTime * 0.4 + micInput * 0.5); // Modulate color with mic input\n    vec2 uv = C.xy * 2.0 / iResolution.xy + (cPos / cLength) * cos(cLength * 1.0 - iTime * 4.0) * 0.03;\n    \n    for (float g, e, i; i++ < 45.0;) {\n        vec3 p = g * vec3((C * 2.0 - iResolution.xy) / iResolution.y, 1);\n        p.z += -iTime;\n        p.xy += uv;\n        p.xz += uv;\n        p.yx *= mat2(cos(iTime * 0.5), sin(iTime * 0.5), -sin(iTime * 0.5), cos(iTime * 0.5));\n        \n        p = fract(p) - 0.5;\n        \n        G(p.xy, 0.3);\n        G(p.zy, 0.11);\n        G(p.yx, 0.15);\n        g += e = 0.6 * length(p.xz) - 0.01;\n        e < 0.01 ? O += abs(cos(p.z * 99.0)) / i : O * col.x;\n    }\n    \n    uv2 *= 2.0 * (cos(iTime * 2.0) - 2.5); // Scale\n    \n    float anim = sin(iTime * 12.0) * 0.1 + 1.0; // Anim between 0.9 - 1.1\n    O *= vec4(happy_star(uv2, anim) * vec3(0.25, 0.1, 5.55), 1.0);\n}",
  "\n\n#define R(a)a=vec2(a.x+a.y,a.x-a.y)*.7\n#define G(a,n)R(a);a=abs(a+0.02)-n;R(a)\n#define R2D(a) mat2( cos( a + vec4(0,11,33,0 )))\n  \n// Function to generate a color palette with more vibrant colors\nvec3 palette(float t) {\n    vec3 a = vec3(0.25, 0.15, 0.35); // Slightly more vibrant base color\n    vec3 b = vec3(0.55, 0.45, 0.65); // Increased brightness\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.283, 0.536, 0.677); // Tweaked modulation vector for more variation\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Function to sample average amplitude from microphone input\nfloat getAudioAmplitude() {\n    float amplitude = 0.0;\n    for (int i = 0; i < 256; i++) {\n        amplitude += texture(iChannel1, vec2(float(i) / 256.0, 0.0)).r;\n    }\n    return amplitude / 256.0;\n}\n\n// Function to create a swirling motion towards the center\nvec2 swirl(vec2 uv, float time, float scale, float speed) {\n    float angle = length(uv) * scale - time * speed;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot * uv;\n}\n\n// Function to offset the camera based on time and audio input\nvec2 cameraOffset(vec2 uv, float time, float audioAmp) {\n    float offsetX = sin(time * 0.2) * 0.5 + audioAmp * 0.2;\n    float offsetY = cos(time * 0.1) * 0.5 + audioAmp * 0.2;\n    return uv + vec2(offsetX, offsetY);\n}\n\nvoid mainImage(out vec4 O, vec2 C) {\n    // Sample the microphone input (FFT)\n    float micInput = texture2D(iChannel1, vec2(0.0, 0.0)).r;\n\n    // Get the average audio amplitude\n    float audioAmplitude = getAudioAmplitude();\n\n    // Modulate rotation speed based on audio amplitude\n    float rotationSpeed = iTime * (1.0 + audioAmplitude * 5.0);\n\n    O = vec4(0);\n    vec2 cPos = -1.0 + 2.0 * C.xy / iResolution.xy;\n\n    // Distance of current pixel from center\n    float cLength = length(cPos);\n    vec2 uv = (C - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Apply camera offset to create motion effect\n    uv = cameraOffset(uv, iTime, audioAmplitude);\n\n    // Apply multiple swirling motions with different scales and speeds\n    uv = swirl(uv, iTime, 5.0, 2.0);\n    uv = swirl(uv, iTime * 0.5, 3.0, 1.5);\n    uv = swirl(uv, iTime * 0.25, 2.0, 1.0);\n\n    // Pulse effect based on sine wave synchronized with time and audio amplitude\n    float pulse = 0.5 + 0.5 * sin(iTime * 2.0 + audioAmplitude * 10.0);\n\n    // Modulate color with mic input, distance from center, and pulse effect\n    vec3 col = palette(length(uv) + 0.4 + iTime * 0.4 + micInput * 0.5);\n    col *= pulse; // Apply pulsing effect\n    col *= 1.0 - smoothstep(0.0, 1.0, cLength); // Darken towards the center\n\n    // Create the vortex effect\n    for (float g, e, i; i++ < 45.0;) {\n        vec3 p = g * vec3((C * 2.0 - iResolution.xy) / iResolution.y, 1);\n        p.z += -iTime;\n        p.xy += uv;\n        p.xz += uv;\n        p.yx *= mat2(cos(iTime * 0.5), sin(iTime * 0.5), -sin(iTime * 0.5), cos(iTime * 0.5));\n\n        p = fract(p) - 0.5;\n\n        G(p.xy, 0.3);\n        G(p.zy, 0.11);\n        G(p.yx, 0.15);\n        g += e = 0.6 * length(p.xz) - 0.01;\n        e < 0.01 ? O += abs(cos(p.z * 99.0)) / i : O * col.x;\n    }\n\n    // Blend with the rotating 3D pattern\n    float d = .1, e;\n    vec3 p, q = vec3(-1), r = iResolution;\n\n    for(float i = 0.; i++ < 64. && d > 1e-4;) {\n        p = vec3((C.xy - .5 * r.xy) / r.y, e);\n        p = mod(p - cos(p - .5), 4.) - 1.2;\n        p.zx *= R2D(rotationSpeed);\n        p.yz *= R2D(rotationSpeed);\n\n        for(float j = 0.; j++ < 8.;)\n            p = 1. / abs(abs(p * mix(p, q, .34))),\n            d = dot(1.05, dot(p, p)),\n            d -= length(p.xy) / 1e4;\n\n        e -= d;\n    }\n    O += vec4(col * (3. / 64.), 1.0);\n}",
  "\n\n#define R(a)a=vec2(a.x+a.y,a.x-a.y)*.7\n#define G(a,n)R(a);a=abs(a+0.02)-n;R(a)\n#define R2D(a) mat2( cos( a + vec4(0,11,33,0 )))\n\n// Function to generate a color palette with more vibrant colors\nvec3 palette(float t) {\n    vec3 a = vec3(0.25, 0.15, 0.35); // Slightly more vibrant base color\n    vec3 b = vec3(0.55, 0.45, 0.65); // Increased brightness\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.283, 0.536, 0.677); // Tweaked modulation vector for more variation\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Function to sample average amplitude from microphone input\nfloat getAudioAmplitude() {\n    float amplitude = 0.0;\n    for (int i = 0; i < 256; i++) {\n        amplitude += texture(iChannel1, vec2(float(i) / 256.0, 0.0)).r;\n    }\n    return amplitude / 256.0;\n}\n\n// Function to create a swirling motion towards the center\nvec2 swirl(vec2 uv, float time, float scale, float speed) {\n    float angle = length(uv) * scale - time * speed;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot * uv;\n}\n\nvoid mainImage(out vec4 O, vec2 C) {\n    // Sample the microphone input (FFT)\n    float micInput = texture2D(iChannel1, vec2(0.0, 0.0)).r;\n\n    // Get the average audio amplitude\n    float audioAmplitude = getAudioAmplitude();\n\n    // Modulate rotation speed based on audio amplitude\n    float rotationSpeed = iTime * (1.0 + audioAmplitude * 5.0);\n\n    O = vec4(0);\n    vec2 cPos = -1.0 + 2.0 * C.xy / iResolution.xy;\n\n    // Distance of current pixel from center\n    float cLength = length(cPos);\n    vec2 uv = (C - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Apply multiple swirling motions with different scales and speeds\n    uv = swirl(uv, iTime, 5.0, 2.0);\n    uv = swirl(uv, iTime * 0.5, 3.0, 1.5);\n    uv = swirl(uv, iTime * 0.25, 2.0, 1.0);\n\n    // Pulse effect based on sine wave synchronized with time and audio amplitude\n    float pulse = 0.5 + 0.5 * sin(iTime * 2.0 + audioAmplitude * 10.0);\n\n    // Modulate color with mic input, distance from center, and pulse effect\n    vec3 col = palette(length(uv) + 0.4 + iTime * 0.4 + micInput * 0.5);\n    col *= pulse; // Apply pulsing effect\n    col *= 1.0 - smoothstep(0.0, 1.0, cLength); // Darken towards the center\n\n    // Create the vortex effect\n    for (float g, e, i; i++ < 45.0;) {\n        vec3 p = g * vec3((C * 2.0 - iResolution.xy) / iResolution.y, 1);\n        p.z += -iTime;\n        p.xy += uv;\n        p.xz += uv;\n        p.yx *= mat2(cos(iTime * 0.5), sin(iTime * 0.5), -sin(iTime * 0.5), cos(iTime * 0.5));\n\n        p = fract(p) - 0.5;\n\n        G(p.xy, 0.3);\n        G(p.zy, 0.11);\n        G(p.yx, 0.15);\n        g += e = 0.6 * length(p.xz) - 0.01;\n        e < 0.01 ? O += abs(cos(p.z * 99.0)) / i : O * col.x;\n    }\n\n    // Blend with the rotating 3D pattern\n    float d = .1, e;\n    vec3 p, q = vec3(-1), r = iResolution;\n\n    for(float i = 0.; i++ < 64. && d > 1e-4;) {\n        p = vec3((C.xy - .5 * r.xy) / r.y, e);\n        p = mod(p - cos(p - .5), 4.) - 1.2;\n        p.zx *= R2D(rotationSpeed);\n        p.yz *= R2D(rotationSpeed);\n\n        for(float j = 0.; j++ < 8.;)\n            p = 1. / abs(abs(p * mix(p, q, .34))),\n            d = dot(1.05, dot(p, p)),\n            d -= length(p.xy) / 1e4;\n\n        e -= d;\n    }  \n    O += vec4(col * (3. / 64.), 1.0);\n}",
  "\n\n#define PI (3.14159265)\n#define TAU (PI*2. )\n\n// Function to generate a color palette with more vibrant colors\nvec3 palette(float t) {\n    vec3 a = vec3(0.25, 0.15, 0.35);\n    vec3 b = vec3(0.55, 0.45, 0.65);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.283, 0.536, 0.677);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Function to sample average amplitude from microphone input\nfloat getAudioAmplitude() {\n    float amplitude = 0.0;\n    for (int i = 0; i < 256; i++) {\n        amplitude += texture(iChannel1, vec2(float(i) / 256.0, 0.0)).r;\n    }\n    return amplitude / 256.0;\n}\n\n// Function to create a swirling motion towards the center\nvec2 swirl(vec2 uv, float time, float scale, float speed) {\n    float angle = length(uv) * scale - time * speed;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot * uv;\n}\n\n// Function to calculate the distance to the next plane of objects\nvec3 Dist(vec3 beg, vec3 dir, float spread, out float depth) {\n    float zz = 1. - fract(beg.z);\n    depth = 0.0;\n    while (beg.z < 50.0) {\n        beg += dir * (zz - fract(dir.z));\n        float x = fract(beg.x), y = fract(beg.y);\n        if (max(x, y) < 0.5 && !(x > 0.1 && x < 0.4 && y > 0.1 && y < 0.4) && beg.z > 3.0)\n            break;\n        zz = beg.z > 3.0 ? spread : 1.0;\n        if (beg.z > 3.0) ++depth;\n    }\n    return beg;\n}\n\n// Function to rotate a 2D vector\nvec2 rot2d(vec2 inp, float ang) {\n    float s = sin(ang);\n    float c = cos(ang);\n    return vec2(inp.x * c + inp.y * s, inp.y * c - inp.x * s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n    uv = rot2d(uv, iTime / 17.0);\n\n    float spread = 0.8 + sin(iTime * 0.7) * 0.75;\n    float depth;\n    vec3 cam = vec3(0.0 + sin(iTime * 0.13) * 0.5, 0.0 + sin(iTime / 12.0) + iTime / 10.0, 2.0 + cos(iTime * 0.2) * 1.9);\n    vec3 camdir = vec3(uv.x, uv.y, 1.0);\n    vec3 hit = Dist(cam, camdir, spread, depth);\n\n    // Sample the microphone input and get the average audio amplitude\n    float micInput = texture2D(iChannel1, vec2(0.0, 0.0)).r;\n    float audioAmplitude = getAudioAmplitude();\n\n    // Modulate rotation speed based on audio amplitude\n    float rotationSpeed = iTime * (1.0 + audioAmplitude * 5.0);\n\n    // Apply swirling motion to the 3D pattern\n    uv = swirl(uv, iTime, 5.0, 2.0);\n    uv = swirl(uv, iTime * 0.5, 3.0, 1.5);\n    uv = swirl(uv, iTime * 0.25, 2.0, 1.0);\n\n    // Generate color based on the palette function\n    vec3 col = palette(length(uv) + 0.4 + iTime * 0.4 + micInput * 0.5);\n\n    // Apply depth-based color modulation\n    col *= 5.0 * sin(vec3(0.0, PI / 3.0, PI * 2.0 / 3.0) + depth * 0.6) / hit.z;\n    col = mix(col, vec3(4.0 / hit.z), 0.85);\n\n    fragColor = vec4(col, 1.0);\n}\n",
  "\n#define PI (3.14159265)\n#define TAU (PI*2.)\n\n// Function to generate a color palette with more vibrant colors\nvec3 palette(float t) {\n    vec3 a = vec3(0.25, 0.15, 0.35);\n    vec3 b = vec3(0.55, 0.45, 0.65);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.283, 0.536, 0.677);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Function to sample average amplitude from microphone input\nfloat getAudioAmplitude() {\n    float amplitude = 0.0;\n    for (int i = 0; i < 256; i++) {\n        amplitude += texture(iChannel1, vec2(float(i) / 256.0, 0.0)).r;\n    }\n    return amplitude / 256.0;\n}\n\n// Function to create a swirling motion towards the center\nvec2 swirl(vec2 uv, float time, float scale, float speed) {\n    float angle = length(uv) * scale - time * speed;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot * uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n\n    // Sample the microphone input and get the average audio amplitude\n    float micInput = texture2D(iChannel1, vec2(0.0, 0.0)).r;\n    float audioAmplitude = getAudioAmplitude();\n\n    // Modulate rotation speed based on audio amplitude\n    float rotationSpeed = iTime * (1.0 + audioAmplitude * 5.0);\n\n    // Apply swirling motion to the 3D pattern\n    uv = swirl(uv, iTime, 5.0, 2.0);\n    uv = swirl(uv, iTime * 0.5, 3.0, 1.5);\n    uv = swirl(uv, iTime * 0.25, 2.0, 1.0);\n\n    // Pulse effect based on sine wave synchronized with time and audio amplitude\n    float pulse = 0.5 + 0.5 * sin(iTime * 2.0 + audioAmplitude * 10.0);\n \n    // Modulate color with mic input, distance from center, and pulse effect\n    vec3 col = palette(length(uv) + 0.4 + iTime * 0.4 + micInput * 0.5);\n    col *= pulse; // Apply pulsing effect\n\n    // Create the vortex effect\n    for (float g, e, i; i++ < 45.0;) {\n        vec3 p = g * vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y, 1);\n        p.z += -iTime;\n        p.xy += uv;\n        p.xz += uv;\n        p.yx *= mat2(cos(iTime * 0.5), sin(iTime * 0.5), -sin(iTime * 0.5), cos(iTime * 0.5));\n\n        p = fract(p) - 0.5;\n\n        g += e = 0.6 * length(p.xz) - 0.01;\n        e < 0.01 ? fragColor += abs(cos(p.z * 99.0)) / i : fragColor * col.x;\n    }\n\n    // Blend with the rotating 3D pattern\n    float d = .1, e;\n    vec3 p, q = vec3(-1), r = iResolution;\n\n    for(float i = 0.; i++ < 64. && d > 1e-4;) {\n        p = vec3((fragCoord.xy - .5 * r.xy) / r.y, e);\n        p = mod(p - cos(p - .5), 4.) - 1.2;\n        p.zx *= mat2(cos(rotationSpeed), sin(rotationSpeed), -sin(rotationSpeed), cos(rotationSpeed));\n        p.yz *= mat2(cos(rotationSpeed), sin(rotationSpeed), -sin(rotationSpeed), cos(rotationSpeed));\n\n        for(float j = 0.; j++ < 8.;)\n            p = 1. / abs(abs(p * mix(p, q, .34))),\n            d = dot(1.05, dot(p, p)),\n            d -= length(p.xy) / 1e4;\n\n        e -= d;\n    }\n    fragColor += vec4(col * (3. / 64.), 1.0);\n}\n",
  "\n#define PI (3.14159265)\n#define TAU (PI*2.)\n\n// Function to generate a vibrant color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.2, 0.7);\n    vec3 b = vec3(0.8, 0.4, 0.9);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.3, 0.6, 0.8);\n\n    return a + b * cos(TAU * (c * t + d));\n}\n\n// Function to sample average amplitude from microphone input\nfloat getAudioAmplitude() {\n    float amplitude = 0.0;\n    for (int i = 0; i < 256; i++) {\n        amplitude += texture(iChannel1, vec2(float(i) / 256.0, 0.0)).r;\n    }\n    return amplitude / 256.0;\n}\n\n// Function to create a swirling motion towards the center\nvec2 swirl(vec2 uv, float time, float scale, float speed) {\n    float angle = length(uv) * scale - time * speed;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot * uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n\n    // Sample the microphone input and get the average audio amplitude\n    float audioAmplitude = getAudioAmplitude();\n\n    // Modulate rotation speed based on audio amplitude\n    float rotationSpeed = iTime * (1.0 + audioAmplitude * 5.0);\n\n    // Apply swirling motion to the 3D pattern\n    uv = swirl(uv, iTime, 5.0, 2.0);\n    uv = swirl(uv, iTime * 0.5, 3.0, 1.5);\n    uv = swirl(uv, iTime * 0.25, 2.0, 1.0);\n\n    // Pulse effect based on sine wave synchronized with time and audio amplitude\n    float pulse = 0.5 + 0.5 * sin(iTime * 10.0 + audioAmplitude * 20.0);\n\n    // Modulate color with mic input, distance from center, and pulse effect\n    vec3 col = palette(length(uv) + 0.4 + iTime * 0.4 + audioAmplitude * 0.5);\n    col *= pulse; // Apply pulsing effect\n\n    // Create the vortex effect\n    for (float g, e, i = 0.0; i < 45.0; i++) {\n        vec3 p = g * vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y, 1);\n        p.z += -iTime;\n        p.xy += uv;\n        p.xz += uv;\n        p.yx *= mat2(cos(iTime * 0.5), sin(iTime * 0.5), -sin(iTime * 0.5), cos(iTime * 0.5));\n\n        p = fract(p) - 0.5;\n\n        g += e = 0.6 * length(p.xz) - 0.01;\n        if (e < 0.01) {\n            fragColor += abs(cos(p.z * 99.0)) / i;\n        } else {\n            fragColor *= col.x;\n        }\n    }\n\n    // Blend with the rotating 3D pattern\n    float d = .1, e;\n    vec3 p, q = vec3(-1), r = iResolution;\n\n    for (float i = 0.; i < 64.; i++) {\n        p = vec3((fragCoord.xy - .5 * r.xy) / r.y, e);\n        p = mod(p - cos(p - .5), 4.) - 1.2;\n        p.zx *= mat2(cos(rotationSpeed), sin(rotationSpeed), -sin(rotationSpeed), cos(rotationSpeed));\n        p.yz *= mat2(cos(rotationSpeed), sin(rotationSpeed), -sin(rotationSpeed), cos(rotationSpeed));\n\n        for (float j = 0.; j < 8.; j++) {\n            p = 1. / abs(abs(p * mix(p, q, .34)));\n            d = dot(1.05, dot(p, p));\n            d -= length(p.xy) / 1e4;\n        }\n\n        e -= d;\n    }\n\n    fragColor += vec4(col * (3. / 64.), 1.0);\n}\n",
  "\n#define PI (3.14159265)\n#define TAU (PI*2.)\n\n// Function to generate a vibrant color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.2, 0.7);\n    vec3 b = vec3(0.8, 0.4, 0.9);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.3, 0.6, 0.8);\n\n    return a + b * cos(TAU * (c * t + d));\n}\n\n// Function to sample average amplitude from microphone input\nfloat getAudioAmplitude() {\n    float amplitude = 0.0;\n    for (int i = 0; i < 256; i++) {\n        amplitude += texture(iChannel1, vec2(float(i) / 256.0, 0.0)).r;\n    }\n    return amplitude / 256.0;\n}\n\n// Function to create a swirling motion towards the center\nvec2 swirl(vec2 uv, float time, float scale, float speed) {\n    float angle = length(uv) * scale - time * speed;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot * uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n\n    // Sample the microphone input and get the average audio amplitude\n    float audioAmplitude = getAudioAmplitude();\n\n    // Modulate rotation speed based on audio amplitude\n    float rotationSpeed = iTime * (1.0 + audioAmplitude * 5.0);\n\n    // Define the number of slices\n    int slices = 10;\n    float sliceSize = 2.0 / float(slices);\n    \n    // Determine the slice index for the current fragment\n    int sliceIndexX = int((uv.x + 1.0) / sliceSize);\n    int sliceIndexY = int((uv.y + 1.0) / sliceSize);\n\n    // Offset each slice differently\n    vec2 sliceOffset = vec2(sliceIndexX, sliceIndexY) * sliceSize - 1.0;\n\n    // Apply swirling motion to the 3D pattern within each slice\n    uv = swirl(uv - sliceOffset, iTime, 5.0, 2.0);\n    uv = swirl(uv, iTime * 0.5, 3.0, 1.5);\n    uv = swirl(uv, iTime * 0.25, 2.0, 1.0);\n\n    // Pulse effect based on sine wave synchronized with time and audio amplitude\n    float pulse = 0.5 + 0.5 * sin(iTime * 10.0 + audioAmplitude * 20.0);\n\n    // Modulate color with mic input, distance from center, and pulse effect\n    vec3 col = palette(length(uv) + 0.4 + iTime * 0.4 + audioAmplitude * 0.5);\n    col *= pulse; // Apply pulsing effect\n\n    // Create the vortex effect\n    for (float g, e, i = 0.0; i < 45.0; i++) {\n        vec3 p = g * vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y, 1);\n        p.z += -iTime;\n        p.xy += uv;\n        p.xz += uv;\n        p.yx *= mat2(cos(iTime * 0.5), sin(iTime * 0.5), -sin(iTime * 0.5), cos(iTime * 0.5));\n\n        p = fract(p) - 0.5;\n\n        g += e = 0.6 * length(p.xz) - 0.01;\n        if (e < 0.01) {\n            fragColor += abs(cos(p.z * 99.0)) / i;\n        } else {\n            fragColor *= col.x;\n        }\n    }\n\n    // Blend with the rotating 3D pattern\n    float d = .1, e;\n    vec3 p, q = vec3(-1), r = iResolution;\n\n    for (float i = 0.; i < 64.; i++) {\n        p = vec3((fragCoord.xy - .5 * r.xy) / r.y, e);\n        p = mod(p - cos(p - .5), 4.) - 1.2;\n        p.zx *= mat2(cos(rotationSpeed), sin(rotationSpeed), -sin(rotationSpeed), cos(rotationSpeed));\n        p.yz *= mat2(cos(rotationSpeed), sin(rotationSpeed), -sin(rotationSpeed), cos(rotationSpeed));\n\n        for (float j = 0.; j < 8.; j++) {\n            p = 1. / abs(abs(p * mix(p, q, .34)));\n            d = dot(1.05, dot(p, p));\n            d -= length(p.xy) / 1e4;\n        }\n\n        e -= d;\n    }\n\n    fragColor += vec4(col * (3. / 64.), 1.0);\n}\n",
  "\n#define PI (3.14159265)\n#define TAU (PI*2.)\n\n// Function to generate a vibrant color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.2, 0.7);\n    vec3 b = vec3(0.8, 0.4, 0.9);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.3, 0.6, 0.8);\n\n    return a + b * cos(TAU * (c * t + d));\n}\n\n// Function to sample average amplitude from microphone input\nfloat getAudioAmplitude() {\n    float amplitude = 0.0;\n    for (int i = 0; i < 256; i++) {\n        amplitude += texture(iChannel1, vec2(float(i) / 256.0, 0.0)).r;\n    }\n    return amplitude / 256.0;\n}\n\n// Function to create a swirling motion towards the center\nvec2 swirl(vec2 uv, float time, float scale, float speed) {\n    float angle = length(uv) * scale - time * speed;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot * uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n\n    // Sample the microphone input and get the average audio amplitude\n    float audioAmplitude = getAudioAmplitude();\n\n    // Modulate rotation speed based on audio amplitude\n    float rotationSpeed = iTime * (1.0 + audioAmplitude * 5.0);\n\n    // Define the number of slices\n    int slices = 10;\n    float sliceSize = 2.0 / float(slices);\n    \n    // Determine the slice index for the current fragment\n    int sliceIndexX = int((uv.x + 1.0) / sliceSize);\n    int sliceIndexY = int((uv.y + 1.0) / sliceSize);\n\n    // Introduce time-based sliding offset\n    float timeOffset = iTime * 0.5;\n\n    // Offset each slice differently with sliding effect\n    vec2 sliceOffset = vec2(sliceIndexX, sliceIndexY) * sliceSize - 1.0 + vec2(sin(timeOffset + float(sliceIndexX)), cos(timeOffset + float(sliceIndexY))) * 0.5;\n\n    // Apply swirling motion to the 3D pattern within each slice\n    uv = swirl(uv - sliceOffset, iTime, 5.0, 2.0);\n    uv = swirl(uv, iTime * 0.5, 3.0, 1.5);\n    uv = swirl(uv, iTime * 0.25, 2.0, 1.0);\n\n    // Pulse effect based on sine wave synchronized with time and audio amplitude\n    float pulse = 0.5 + 0.5 * sin(iTime * 10.0 + audioAmplitude * 20.0);\n\n    // Modulate color with mic input, distance from center, and pulse effect\n    vec3 col = palette(length(uv) + 0.4 + iTime * 0.4 + audioAmplitude * 0.5);\n    col *= pulse; // Apply pulsing effect\n\n    // Create the vortex effect\n    for (float g, e, i = 0.0; i < 45.0; i++) {\n        vec3 p = g * vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y, 1);\n        p.z += -iTime;\n        p.xy += uv;\n        p.xz += uv;\n        p.yx *= mat2(cos(iTime * 0.5), sin(iTime * 0.5), -sin(iTime * 0.5), cos(iTime * 0.5));\n\n        p = fract(p) - 0.5;\n\n        g += e = 0.6 * length(p.xz) - 0.01;\n        if (e < 0.01) {\n            fragColor += abs(cos(p.z * 99.0)) / i;\n        } else {\n            fragColor *= col.x;\n        }\n    }\n\n    // Blend with the rotating 3D pattern\n    float d = .1, e;\n    vec3 p, q = vec3(-1), r = iResolution;\n\n    for (float i = 0.; i < 64.; i++) {\n        p = vec3((fragCoord.xy - .5 * r.xy) / r.y, e);\n        p = mod(p - cos(p - .5), 4.) - 1.2;\n        p.zx *= mat2(cos(rotationSpeed), sin(rotationSpeed), -sin(rotationSpeed), cos(rotationSpeed));\n        p.yz *= mat2(cos(rotationSpeed), sin(rotationSpeed), -sin(rotationSpeed), cos(rotationSpeed));\n\n        for (float j = 0.; j < 8.; j++) {\n            p = 1. / abs(abs(p * mix(p, q, .34)));\n            d = dot(1.05, dot(p, p));\n            d -= length(p.xy) / 1e4;\n        }\n\n        e -= d;\n    }\n\n    fragColor += vec4(col * (3. / 64.), 1.0);\n}\n"
]